module.exports = "/*!***************************************************\r\n * mark.js v9.0.0\r\n * https://markjs.io/\r\n * Copyright (c) 2014–2018, Julian Kühnel\r\n * Released under the MIT license https://git.io/vwTVl\r\n *****************************************************/\r\n\r\n(function (global, factory) {\r\n  typeof exports === \"object\" && typeof module !== \"undefined\"\r\n    ? (module.exports = factory())\r\n    : typeof define === \"function\" && define.amd\r\n    ? define(factory)\r\n    : (global.Mark = factory());\r\n})(this, function () {\r\n  \"use strict\";\r\n\r\n  class DOMIterator {\r\n    constructor(ctx, iframes = true, exclude = [], iframesTimeout = 5000) {\r\n      this.ctx = ctx;\r\n      this.iframes = iframes;\r\n      this.exclude = exclude;\r\n      this.iframesTimeout = iframesTimeout;\r\n    }\r\n    static matches(element, selector) {\r\n      const selectors = typeof selector === \"string\" ? [selector] : selector,\r\n        fn =\r\n          element.matches ||\r\n          element.matchesSelector ||\r\n          element.msMatchesSelector ||\r\n          element.mozMatchesSelector ||\r\n          element.oMatchesSelector ||\r\n          element.webkitMatchesSelector;\r\n      if (fn) {\r\n        let match = false;\r\n        selectors.every((sel) => {\r\n          if (fn.call(element, sel)) {\r\n            match = true;\r\n            return false;\r\n          }\r\n          return true;\r\n        });\r\n        return match;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n    getContexts() {\r\n      let ctx,\r\n        filteredCtx = [];\r\n      if (typeof this.ctx === \"undefined\" || !this.ctx) {\r\n        ctx = [];\r\n      } else if (NodeList.prototype.isPrototypeOf(this.ctx)) {\r\n        ctx = Array.prototype.slice.call(this.ctx);\r\n      } else if (Array.isArray(this.ctx)) {\r\n        ctx = this.ctx;\r\n      } else if (typeof this.ctx === \"string\") {\r\n        ctx = Array.prototype.slice.call(document.querySelectorAll(this.ctx));\r\n      } else {\r\n        ctx = [this.ctx];\r\n      }\r\n      ctx.forEach((ctx) => {\r\n        const isDescendant =\r\n          filteredCtx.filter((contexts) => {\r\n            return contexts.contains(ctx);\r\n          }).length > 0;\r\n        if (filteredCtx.indexOf(ctx) === -1 && !isDescendant) {\r\n          filteredCtx.push(ctx);\r\n        }\r\n      });\r\n      return filteredCtx;\r\n    }\r\n    getIframeContents(ifr, successFn, errorFn = () => {}) {\r\n      let doc;\r\n      try {\r\n        const ifrWin = ifr.contentWindow;\r\n        doc = ifrWin.document;\r\n        if (!ifrWin || !doc) {\r\n          throw new Error(\"iframe inaccessible\");\r\n        }\r\n      } catch (e) {\r\n        errorFn();\r\n      }\r\n      if (doc) {\r\n        successFn(doc);\r\n      }\r\n    }\r\n    isIframeBlank(ifr) {\r\n      const bl = \"about:blank\",\r\n        src = ifr.getAttribute(\"src\").trim(),\r\n        href = ifr.contentWindow.location.href;\r\n      return href === bl && src !== bl && src;\r\n    }\r\n    observeIframeLoad(ifr, successFn, errorFn) {\r\n      let called = false,\r\n        tout = null;\r\n      const listener = () => {\r\n        if (called) {\r\n          return;\r\n        }\r\n        called = true;\r\n        clearTimeout(tout);\r\n        try {\r\n          if (!this.isIframeBlank(ifr)) {\r\n            ifr.removeEventListener(\"load\", listener);\r\n            this.getIframeContents(ifr, successFn, errorFn);\r\n          }\r\n        } catch (e) {\r\n          errorFn();\r\n        }\r\n      };\r\n      ifr.addEventListener(\"load\", listener);\r\n      tout = setTimeout(listener, this.iframesTimeout);\r\n    }\r\n    onIframeReady(ifr, successFn, errorFn) {\r\n      try {\r\n        if (ifr.contentWindow.document.readyState === \"complete\") {\r\n          if (this.isIframeBlank(ifr)) {\r\n            this.observeIframeLoad(ifr, successFn, errorFn);\r\n          } else {\r\n            this.getIframeContents(ifr, successFn, errorFn);\r\n          }\r\n        } else {\r\n          this.observeIframeLoad(ifr, successFn, errorFn);\r\n        }\r\n      } catch (e) {\r\n        errorFn();\r\n      }\r\n    }\r\n    waitForIframes(ctx, done) {\r\n      let eachCalled = 0;\r\n      this.forEachIframe(\r\n        ctx,\r\n        () => true,\r\n        (ifr) => {\r\n          eachCalled++;\r\n          this.waitForIframes(ifr.querySelector(\"html\"), () => {\r\n            if (!--eachCalled) {\r\n              done();\r\n            }\r\n          });\r\n        },\r\n        (handled) => {\r\n          if (!handled) {\r\n            done();\r\n          }\r\n        }\r\n      );\r\n    }\r\n    forEachIframe(ctx, filter, each, end = () => {}) {\r\n      let ifr = ctx.querySelectorAll(\"iframe\"),\r\n        open = ifr.length,\r\n        handled = 0;\r\n      ifr = Array.prototype.slice.call(ifr);\r\n      const checkEnd = () => {\r\n        if (--open <= 0) {\r\n          end(handled);\r\n        }\r\n      };\r\n      if (!open) {\r\n        checkEnd();\r\n      }\r\n      ifr.forEach((ifr) => {\r\n        if (DOMIterator.matches(ifr, this.exclude)) {\r\n          checkEnd();\r\n        } else {\r\n          this.onIframeReady(\r\n            ifr,\r\n            (con) => {\r\n              if (filter(ifr)) {\r\n                handled++;\r\n                each(con);\r\n              }\r\n              checkEnd();\r\n            },\r\n            checkEnd\r\n          );\r\n        }\r\n      });\r\n    }\r\n    createIterator(ctx, whatToShow, filter) {\r\n      return document.createNodeIterator(ctx, whatToShow, filter, false);\r\n    }\r\n    createInstanceOnIframe(contents) {\r\n      return new DOMIterator(contents.querySelector(\"html\"), this.iframes);\r\n    }\r\n    compareNodeIframe(node, prevNode, ifr) {\r\n      const compCurr = node.compareDocumentPosition(ifr),\r\n        prev = Node.DOCUMENT_POSITION_PRECEDING;\r\n      if (compCurr & prev) {\r\n        if (prevNode !== null) {\r\n          const compPrev = prevNode.compareDocumentPosition(ifr),\r\n            after = Node.DOCUMENT_POSITION_FOLLOWING;\r\n          if (compPrev & after) {\r\n            return true;\r\n          }\r\n        } else {\r\n          return true;\r\n        }\r\n      }\r\n      return false;\r\n    }\r\n    getIteratorNode(itr) {\r\n      const prevNode = itr.previousNode();\r\n      let node;\r\n      if (prevNode === null) {\r\n        node = itr.nextNode();\r\n      } else {\r\n        node = itr.nextNode() && itr.nextNode();\r\n      }\r\n      return {\r\n        prevNode,\r\n        node,\r\n      };\r\n    }\r\n    checkIframeFilter(node, prevNode, currIfr, ifr) {\r\n      let key = false,\r\n        handled = false;\r\n      ifr.forEach((ifrDict, i) => {\r\n        if (ifrDict.val === currIfr) {\r\n          key = i;\r\n          handled = ifrDict.handled;\r\n        }\r\n      });\r\n      if (this.compareNodeIframe(node, prevNode, currIfr)) {\r\n        if (key === false && !handled) {\r\n          ifr.push({\r\n            val: currIfr,\r\n            handled: true,\r\n          });\r\n        } else if (key !== false && !handled) {\r\n          ifr[key].handled = true;\r\n        }\r\n        return true;\r\n      }\r\n      if (key === false) {\r\n        ifr.push({\r\n          val: currIfr,\r\n          handled: false,\r\n        });\r\n      }\r\n      return false;\r\n    }\r\n    handleOpenIframes(ifr, whatToShow, eCb, fCb) {\r\n      ifr.forEach((ifrDict) => {\r\n        if (!ifrDict.handled) {\r\n          this.getIframeContents(ifrDict.val, (con) => {\r\n            this.createInstanceOnIframe(con).forEachNode(whatToShow, eCb, fCb);\r\n          });\r\n        }\r\n      });\r\n    }\r\n    iterateThroughNodes(whatToShow, ctx, eachCb, filterCb, doneCb) {\r\n      const itr = this.createIterator(ctx, whatToShow, filterCb);\r\n      let ifr = [],\r\n        elements = [],\r\n        node,\r\n        prevNode,\r\n        retrieveNodes = () => {\r\n          ({ prevNode, node } = this.getIteratorNode(itr));\r\n          return node;\r\n        };\r\n      while (retrieveNodes()) {\r\n        if (this.iframes) {\r\n          this.forEachIframe(\r\n            ctx,\r\n            (currIfr) => {\r\n              return this.checkIframeFilter(node, prevNode, currIfr, ifr);\r\n            },\r\n            (con) => {\r\n              this.createInstanceOnIframe(con).forEachNode(\r\n                whatToShow,\r\n                (ifrNode) => elements.push(ifrNode),\r\n                filterCb\r\n              );\r\n            }\r\n          );\r\n        }\r\n        elements.push(node);\r\n      }\r\n      elements.forEach((node) => {\r\n        eachCb(node);\r\n      });\r\n      if (this.iframes) {\r\n        this.handleOpenIframes(ifr, whatToShow, eachCb, filterCb);\r\n      }\r\n      doneCb();\r\n    }\r\n    forEachNode(whatToShow, each, filter, done = () => {}) {\r\n      const contexts = this.getContexts();\r\n      let open = contexts.length;\r\n      if (!open) {\r\n        done();\r\n      }\r\n      contexts.forEach((ctx) => {\r\n        const ready = () => {\r\n          this.iterateThroughNodes(whatToShow, ctx, each, filter, () => {\r\n            if (--open <= 0) {\r\n              done();\r\n            }\r\n          });\r\n        };\r\n        if (this.iframes) {\r\n          this.waitForIframes(ctx, ready);\r\n        } else {\r\n          ready();\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  class RegExpCreator {\r\n    constructor(options) {\r\n      this.opt = Object.assign(\r\n        {},\r\n        {\r\n          diacritics: true,\r\n          synonyms: {},\r\n          accuracy: \"partially\",\r\n          caseSensitive: false,\r\n          ignoreJoiners: false,\r\n          ignorePunctuation: [],\r\n          wildcards: \"disabled\",\r\n        },\r\n        options\r\n      );\r\n    }\r\n    create(str) {\r\n      if (this.opt.wildcards !== \"disabled\") {\r\n        str = this.setupWildcardsRegExp(str);\r\n      }\r\n      str = this.escapeStr(str);\r\n      if (Object.keys(this.opt.synonyms).length) {\r\n        str = this.createSynonymsRegExp(str);\r\n      }\r\n      if (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) {\r\n        str = this.setupIgnoreJoinersRegExp(str);\r\n      }\r\n      if (this.opt.diacritics) {\r\n        str = this.createDiacriticsRegExp(str);\r\n      }\r\n      str = this.createMergedBlanksRegExp(str);\r\n      if (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) {\r\n        str = this.createJoinersRegExp(str);\r\n      }\r\n      if (this.opt.wildcards !== \"disabled\") {\r\n        str = this.createWildcardsRegExp(str);\r\n      }\r\n      str = this.createAccuracyRegExp(str);\r\n      return new RegExp(str, `gm${this.opt.caseSensitive ? \"\" : \"i\"}`);\r\n    }\r\n    sortByLength(arry) {\r\n      return arry.sort((a, b) =>\r\n        a.length === b.length ? (a > b ? 1 : -1) : b.length - a.length\r\n      );\r\n    }\r\n    escapeStr(str) {\r\n      return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\r\n    }\r\n    createSynonymsRegExp(str) {\r\n      const syn = this.opt.synonyms,\r\n        sens = this.opt.caseSensitive ? \"\" : \"i\",\r\n        joinerPlaceholder =\r\n          this.opt.ignoreJoiners || this.opt.ignorePunctuation.length\r\n            ? \"\\u0000\"\r\n            : \"\";\r\n      for (let index in syn) {\r\n        if (syn.hasOwnProperty(index)) {\r\n          let keys = Array.isArray(syn[index]) ? syn[index] : [syn[index]];\r\n          keys.unshift(index);\r\n          keys = this.sortByLength(keys)\r\n            .map((key) => {\r\n              if (this.opt.wildcards !== \"disabled\") {\r\n                key = this.setupWildcardsRegExp(key);\r\n              }\r\n              key = this.escapeStr(key);\r\n              return key;\r\n            })\r\n            .filter((k) => k !== \"\");\r\n          if (keys.length > 1) {\r\n            str = str.replace(\r\n              new RegExp(\r\n                `(${keys.map((k) => this.escapeStr(k)).join(\"|\")})`,\r\n                `gm${sens}`\r\n              ),\r\n              joinerPlaceholder +\r\n                `(${keys.map((k) => this.processSynonyms(k)).join(\"|\")})` +\r\n                joinerPlaceholder\r\n            );\r\n          }\r\n        }\r\n      }\r\n      return str;\r\n    }\r\n    processSynonyms(str) {\r\n      if (this.opt.ignoreJoiners || this.opt.ignorePunctuation.length) {\r\n        str = this.setupIgnoreJoinersRegExp(str);\r\n      }\r\n      return str;\r\n    }\r\n    setupWildcardsRegExp(str) {\r\n      str = str.replace(/(?:\\\\)*\\?/g, (val) => {\r\n        return val.charAt(0) === \"\\\\\" ? \"?\" : \"\\u0001\";\r\n      });\r\n      return str.replace(/(?:\\\\)*\\*/g, (val) => {\r\n        return val.charAt(0) === \"\\\\\" ? \"*\" : \"\\u0002\";\r\n      });\r\n    }\r\n    createWildcardsRegExp(str) {\r\n      let spaces = this.opt.wildcards === \"withSpaces\";\r\n      return str\r\n        .replace(/\\u0001/g, spaces ? \"[\\\\S\\\\s]?\" : \"\\\\S?\")\r\n        .replace(/\\u0002/g, spaces ? \"[\\\\S\\\\s]*?\" : \"\\\\S*\");\r\n    }\r\n    setupIgnoreJoinersRegExp(str) {\r\n      return str.replace(/[^(|)\\\\]/g, (val, indx, original) => {\r\n        let nextChar = original.charAt(indx + 1);\r\n        if (/[(|)\\\\]/.test(nextChar) || nextChar === \"\") {\r\n          return val;\r\n        } else {\r\n          return val + \"\\u0000\";\r\n        }\r\n      });\r\n    }\r\n    createJoinersRegExp(str) {\r\n      let joiner = [];\r\n      const ignorePunctuation = this.opt.ignorePunctuation;\r\n      if (Array.isArray(ignorePunctuation) && ignorePunctuation.length) {\r\n        joiner.push(this.escapeStr(ignorePunctuation.join(\"\")));\r\n      }\r\n      if (this.opt.ignoreJoiners) {\r\n        joiner.push(\"\\\\u00ad\\\\u200b\\\\u200c\\\\u200d\");\r\n      }\r\n      return joiner.length\r\n        ? str.split(/\\u0000+/).join(`[${joiner.join(\"\")}]*`)\r\n        : str;\r\n    }\r\n    createDiacriticsRegExp(str) {\r\n      const sens = this.opt.caseSensitive ? \"\" : \"i\",\r\n        dct = this.opt.caseSensitive\r\n          ? [\r\n              \"aàáảãạăằắẳẵặâầấẩẫậäåāą\",\r\n              \"AÀÁẢÃẠĂẰẮẲẴẶÂẦẤẨẪẬÄÅĀĄ\",\r\n              \"cçćč\",\r\n              \"CÇĆČ\",\r\n              \"dđď\",\r\n              \"DĐĎ\",\r\n              \"eèéẻẽẹêềếểễệëěēę\",\r\n              \"EÈÉẺẼẸÊỀẾỂỄỆËĚĒĘ\",\r\n              \"iìíỉĩịîïī\",\r\n              \"IÌÍỈĨỊÎÏĪ\",\r\n              \"lł\",\r\n              \"LŁ\",\r\n              \"nñňń\",\r\n              \"NÑŇŃ\",\r\n              \"oòóỏõọôồốổỗộơởỡớờợöøō\",\r\n              \"OÒÓỎÕỌÔỒỐỔỖỘƠỞỠỚỜỢÖØŌ\",\r\n              \"rř\",\r\n              \"RŘ\",\r\n              \"sšśșş\",\r\n              \"SŠŚȘŞ\",\r\n              \"tťțţ\",\r\n              \"TŤȚŢ\",\r\n              \"uùúủũụưừứửữựûüůū\",\r\n              \"UÙÚỦŨỤƯỪỨỬỮỰÛÜŮŪ\",\r\n              \"yýỳỷỹỵÿ\",\r\n              \"YÝỲỶỸỴŸ\",\r\n              \"zžżź\",\r\n              \"ZŽŻŹ\",\r\n            ]\r\n          : [\r\n              \"aàáảãạăằắẳẵặâầấẩẫậäåāąAÀÁẢÃẠĂẰẮẲẴẶÂẦẤẨẪẬÄÅĀĄ\",\r\n              \"cçćčCÇĆČ\",\r\n              \"dđďDĐĎ\",\r\n              \"eèéẻẽẹêềếểễệëěēęEÈÉẺẼẸÊỀẾỂỄỆËĚĒĘ\",\r\n              \"iìíỉĩịîïīIÌÍỈĨỊÎÏĪ\",\r\n              \"lłLŁ\",\r\n              \"nñňńNÑŇŃ\",\r\n              \"oòóỏõọôồốổỗộơởỡớờợöøōOÒÓỎÕỌÔỒỐỔỖỘƠỞỠỚỜỢÖØŌ\",\r\n              \"rřRŘ\",\r\n              \"sšśșşSŠŚȘŞ\",\r\n              \"tťțţTŤȚŢ\",\r\n              \"uùúủũụưừứửữựûüůūUÙÚỦŨỤƯỪỨỬỮỰÛÜŮŪ\",\r\n              \"yýỳỷỹỵÿYÝỲỶỸỴŸ\",\r\n              \"zžżźZŽŻŹ\",\r\n            ];\r\n      let handled = [];\r\n      str.split(\"\").forEach((ch) => {\r\n        dct.every((dct) => {\r\n          if (dct.indexOf(ch) !== -1) {\r\n            if (handled.indexOf(dct) > -1) {\r\n              return false;\r\n            }\r\n            str = str.replace(new RegExp(`[${dct}]`, `gm${sens}`), `[${dct}]`);\r\n            handled.push(dct);\r\n          }\r\n          return true;\r\n        });\r\n      });\r\n      return str;\r\n    }\r\n    createMergedBlanksRegExp(str) {\r\n      return str.replace(/[\\s]+/gim, \"[\\\\s]+\");\r\n    }\r\n    createAccuracyRegExp(str) {\r\n      const chars = \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~¡¿\";\r\n      let acc = this.opt.accuracy,\r\n        val = typeof acc === \"string\" ? acc : acc.value,\r\n        ls = typeof acc === \"string\" ? [] : acc.limiters,\r\n        lsJoin = \"\";\r\n      ls.forEach((limiter) => {\r\n        lsJoin += `|${this.escapeStr(limiter)}`;\r\n      });\r\n      switch (val) {\r\n        case \"partially\":\r\n        default:\r\n          return `()(${str})`;\r\n        case \"complementary\":\r\n          lsJoin = \"\\\\s\" + (lsJoin ? lsJoin : this.escapeStr(chars));\r\n          return `()([^${lsJoin}]*${str}[^${lsJoin}]*)`;\r\n        case \"exactly\":\r\n          return `(^|\\\\s${lsJoin})(${str})(?=$|\\\\s${lsJoin})`;\r\n      }\r\n    }\r\n  }\r\n\r\n  class Mark {\r\n    constructor(ctx) {\r\n      this.ctx = ctx;\r\n      this.ie = false;\r\n      const ua = window.navigator.userAgent;\r\n      if (ua.indexOf(\"MSIE\") > -1 || ua.indexOf(\"Trident\") > -1) {\r\n        this.ie = true;\r\n      }\r\n    }\r\n    set opt(val) {\r\n      this._opt = Object.assign(\r\n        {},\r\n        {\r\n          element: \"\",\r\n          className: \"\",\r\n          exclude: [],\r\n          iframes: false,\r\n          iframesTimeout: 5000,\r\n          separateWordSearch: true,\r\n          acrossElements: false,\r\n          ignoreGroups: 0,\r\n          each: () => {},\r\n          noMatch: () => {},\r\n          filter: () => true,\r\n          done: () => {},\r\n          debug: false,\r\n          log: window.console,\r\n        },\r\n        val\r\n      );\r\n    }\r\n    get opt() {\r\n      return this._opt;\r\n    }\r\n    get iterator() {\r\n      return new DOMIterator(\r\n        this.ctx,\r\n        this.opt.iframes,\r\n        this.opt.exclude,\r\n        this.opt.iframesTimeout\r\n      );\r\n    }\r\n    log(msg, level = \"debug\") {\r\n      const log = this.opt.log;\r\n      if (!this.opt.debug) {\r\n        return;\r\n      }\r\n      if (typeof log === \"object\" && typeof log[level] === \"function\") {\r\n        log[level](`mark.js: ${msg}`);\r\n      }\r\n    }\r\n    getSeparatedKeywords(sv) {\r\n      let stack = [];\r\n      sv.forEach((kw) => {\r\n        if (!this.opt.separateWordSearch) {\r\n          if (kw.trim() && stack.indexOf(kw) === -1) {\r\n            stack.push(kw);\r\n          }\r\n        } else {\r\n          kw.split(\" \").forEach((kwSplitted) => {\r\n            if (kwSplitted.trim() && stack.indexOf(kwSplitted) === -1) {\r\n              stack.push(kwSplitted);\r\n            }\r\n          });\r\n        }\r\n      });\r\n      return {\r\n        keywords: stack.sort((a, b) => {\r\n          return b.length - a.length;\r\n        }),\r\n        length: stack.length,\r\n      };\r\n    }\r\n    isNumeric(value) {\r\n      return Number(parseFloat(value)) == value;\r\n    }\r\n    checkRanges(array) {\r\n      if (\r\n        !Array.isArray(array) ||\r\n        Object.prototype.toString.call(array[0]) !== \"[object Object]\"\r\n      ) {\r\n        this.log(\"markRanges() will only accept an array of objects\");\r\n        this.opt.noMatch(array);\r\n        return [];\r\n      }\r\n      const stack = [];\r\n      let last = 0;\r\n      array\r\n        .sort((a, b) => {\r\n          return a.start - b.start;\r\n        })\r\n        .forEach((item) => {\r\n          let { start, end, valid } = this.callNoMatchOnInvalidRanges(\r\n            item,\r\n            last\r\n          );\r\n          if (valid) {\r\n            item.start = start;\r\n            item.length = end - start;\r\n            stack.push(item);\r\n            last = end;\r\n          }\r\n        });\r\n      return stack;\r\n    }\r\n    callNoMatchOnInvalidRanges(range, last) {\r\n      let start,\r\n        end,\r\n        valid = false;\r\n      if (range && typeof range.start !== \"undefined\") {\r\n        start = parseInt(range.start, 10);\r\n        end = start + parseInt(range.length, 10);\r\n        if (\r\n          this.isNumeric(range.start) &&\r\n          this.isNumeric(range.length) &&\r\n          end - last > 0 &&\r\n          end - start > 0\r\n        ) {\r\n          valid = true;\r\n        } else {\r\n          this.log(\r\n            \"Ignoring invalid or overlapping range: \" +\r\n              `${JSON.stringify(range)}`\r\n          );\r\n          this.opt.noMatch(range);\r\n        }\r\n      } else {\r\n        this.log(`Ignoring invalid range: ${JSON.stringify(range)}`);\r\n        this.opt.noMatch(range);\r\n      }\r\n      return {\r\n        start: start,\r\n        end: end,\r\n        valid: valid,\r\n      };\r\n    }\r\n    checkWhitespaceRanges(range, originalLength, string) {\r\n      let end,\r\n        valid = true,\r\n        max = string.length,\r\n        offset = originalLength - max,\r\n        start = parseInt(range.start, 10) - offset;\r\n      start = start > max ? max : start;\r\n      end = start + parseInt(range.length, 10);\r\n      if (end > max) {\r\n        end = max;\r\n        this.log(`End range automatically set to the max value of ${max}`);\r\n      }\r\n      if (start < 0 || end - start < 0 || start > max || end > max) {\r\n        valid = false;\r\n        this.log(`Invalid range: ${JSON.stringify(range)}`);\r\n        this.opt.noMatch(range);\r\n      } else if (string.substring(start, end).replace(/\\s+/g, \"\") === \"\") {\r\n        valid = false;\r\n        this.log(\"Skipping whitespace only range: \" + JSON.stringify(range));\r\n        this.opt.noMatch(range);\r\n      }\r\n      return {\r\n        start: start,\r\n        end: end,\r\n        valid: valid,\r\n      };\r\n    }\r\n    getTextNodes(cb) {\r\n      let val = \"\",\r\n        nodes = [];\r\n      this.iterator.forEachNode(\r\n        NodeFilter.SHOW_TEXT,\r\n        (node) => {\r\n          nodes.push({\r\n            start: val.length,\r\n            end: (val += node.textContent).length,\r\n            node,\r\n          });\r\n        },\r\n        (node) => {\r\n          if (this.matchesExclude(node.parentNode)) {\r\n            return NodeFilter.FILTER_REJECT;\r\n          } else {\r\n            return NodeFilter.FILTER_ACCEPT;\r\n          }\r\n        },\r\n        () => {\r\n          cb({\r\n            value: val,\r\n            nodes: nodes,\r\n          });\r\n        }\r\n      );\r\n    }\r\n    matchesExclude(el) {\r\n      return DOMIterator.matches(\r\n        el,\r\n        this.opt.exclude.concat([\"script\", \"style\", \"title\", \"head\", \"html\"])\r\n      );\r\n    }\r\n    wrapRangeInTextNode(node, start, end) {\r\n      const hEl = !this.opt.element ? \"mark\" : this.opt.element,\r\n        startNode = node.splitText(start),\r\n        ret = startNode.splitText(end - start);\r\n      let repl = document.createElement(hEl);\r\n      repl.setAttribute(\"data-markjs\", \"true\");\r\n      if (this.opt.className) {\r\n        repl.setAttribute(\"class\", this.opt.className);\r\n      }\r\n      repl.textContent = startNode.textContent;\r\n      startNode.parentNode.replaceChild(repl, startNode);\r\n      return ret;\r\n    }\r\n    wrapRangeInMappedTextNode(dict, start, end, filterCb, eachCb) {\r\n      dict.nodes.every((n, i) => {\r\n        const sibl = dict.nodes[i + 1];\r\n        if (typeof sibl === \"undefined\" || sibl.start > start) {\r\n          if (!filterCb(n.node)) {\r\n            return false;\r\n          }\r\n          const s = start - n.start,\r\n            e = (end > n.end ? n.end : end) - n.start,\r\n            startStr = dict.value.substr(0, n.start),\r\n            endStr = dict.value.substr(e + n.start);\r\n          n.node = this.wrapRangeInTextNode(n.node, s, e);\r\n          dict.value = startStr + endStr;\r\n          dict.nodes.forEach((k, j) => {\r\n            if (j >= i) {\r\n              if (dict.nodes[j].start > 0 && j !== i) {\r\n                dict.nodes[j].start -= e;\r\n              }\r\n              dict.nodes[j].end -= e;\r\n            }\r\n          });\r\n          end -= e;\r\n          eachCb(n.node.previousSibling, n.start);\r\n          if (end > n.end) {\r\n            start = n.end;\r\n          } else {\r\n            return false;\r\n          }\r\n        }\r\n        return true;\r\n      });\r\n    }\r\n    wrapGroups(node, pos, len, eachCb) {\r\n      node = this.wrapRangeInTextNode(node, pos, pos + len);\r\n      eachCb(node.previousSibling);\r\n      return node;\r\n    }\r\n    separateGroups(node, match, matchIdx, filterCb, eachCb) {\r\n      let matchLen = match.length;\r\n      for (let i = 1; i < matchLen; i++) {\r\n        let pos = node.textContent.indexOf(match[i]);\r\n        if (match[i] && pos > -1 && filterCb(match[i], node)) {\r\n          node = this.wrapGroups(node, pos, match[i].length, eachCb);\r\n        }\r\n      }\r\n      return node;\r\n    }\r\n    wrapMatches(regex, ignoreGroups, filterCb, eachCb, endCb) {\r\n      const matchIdx = ignoreGroups === 0 ? 0 : ignoreGroups + 1;\r\n      this.getTextNodes((dict) => {\r\n        dict.nodes.forEach((node) => {\r\n          node = node.node;\r\n          let match;\r\n          while (\r\n            (match = regex.exec(node.textContent)) !== null &&\r\n            match[matchIdx] !== \"\"\r\n          ) {\r\n            if (this.opt.separateGroups) {\r\n              node = this.separateGroups(\r\n                node,\r\n                match,\r\n                matchIdx,\r\n                filterCb,\r\n                eachCb\r\n              );\r\n            } else {\r\n              if (!filterCb(match[matchIdx], node)) {\r\n                continue;\r\n              }\r\n              let pos = match.index;\r\n              if (matchIdx !== 0) {\r\n                for (let i = 1; i < matchIdx; i++) {\r\n                  pos += match[i].length;\r\n                }\r\n              }\r\n              node = this.wrapGroups(node, pos, match[matchIdx].length, eachCb);\r\n            }\r\n            regex.lastIndex = 0;\r\n          }\r\n        });\r\n        endCb();\r\n      });\r\n    }\r\n    wrapMatchesAcrossElements(regex, ignoreGroups, filterCb, eachCb, endCb) {\r\n      const matchIdx = ignoreGroups === 0 ? 0 : ignoreGroups + 1;\r\n      this.getTextNodes((dict) => {\r\n        let match;\r\n        while (\r\n          (match = regex.exec(dict.value)) !== null &&\r\n          match[matchIdx] !== \"\"\r\n        ) {\r\n          let start = match.index;\r\n          if (matchIdx !== 0) {\r\n            for (let i = 1; i < matchIdx; i++) {\r\n              start += match[i].length;\r\n            }\r\n          }\r\n          const end = start + match[matchIdx].length;\r\n          this.wrapRangeInMappedTextNode(\r\n            dict,\r\n            start,\r\n            end,\r\n            (node) => {\r\n              return filterCb(match[matchIdx], node);\r\n            },\r\n            (node, lastIndex) => {\r\n              regex.lastIndex = lastIndex;\r\n              eachCb(node);\r\n            }\r\n          );\r\n        }\r\n        endCb();\r\n      });\r\n    }\r\n    wrapRangeFromIndex(ranges, filterCb, eachCb, endCb) {\r\n      this.getTextNodes((dict) => {\r\n        const originalLength = dict.value.length;\r\n        ranges.forEach((range, counter) => {\r\n          let { start, end, valid } = this.checkWhitespaceRanges(\r\n            range,\r\n            originalLength,\r\n            dict.value\r\n          );\r\n          if (valid) {\r\n            this.wrapRangeInMappedTextNode(\r\n              dict,\r\n              start,\r\n              end,\r\n              (node) => {\r\n                return filterCb(\r\n                  node,\r\n                  range,\r\n                  dict.value.substring(start, end),\r\n                  counter\r\n                );\r\n              },\r\n              (node) => {\r\n                eachCb(node, range);\r\n              }\r\n            );\r\n          }\r\n        });\r\n        endCb();\r\n      });\r\n    }\r\n    unwrapMatches(node) {\r\n      const parent = node.parentNode;\r\n      let docFrag = document.createDocumentFragment();\r\n      while (node.firstChild) {\r\n        docFrag.appendChild(node.removeChild(node.firstChild));\r\n      }\r\n      parent.replaceChild(docFrag, node);\r\n      if (!this.ie) {\r\n        parent.normalize();\r\n      } else {\r\n        this.normalizeTextNode(parent);\r\n      }\r\n    }\r\n    normalizeTextNode(node) {\r\n      if (!node) {\r\n        return;\r\n      }\r\n      if (node.nodeType === 3) {\r\n        while (node.nextSibling && node.nextSibling.nodeType === 3) {\r\n          node.nodeValue += node.nextSibling.nodeValue;\r\n          node.parentNode.removeChild(node.nextSibling);\r\n        }\r\n      } else {\r\n        this.normalizeTextNode(node.firstChild);\r\n      }\r\n      this.normalizeTextNode(node.nextSibling);\r\n    }\r\n    markRegExp(regexp, opt) {\r\n      this.opt = opt;\r\n      this.log(`Searching with expression \"${regexp}\"`);\r\n      let totalMatches = 0,\r\n        fn = \"wrapMatches\";\r\n      const eachCb = (element) => {\r\n        totalMatches++;\r\n        this.opt.each(element);\r\n      };\r\n      if (this.opt.acrossElements) {\r\n        fn = \"wrapMatchesAcrossElements\";\r\n      }\r\n      this[fn](\r\n        regexp,\r\n        this.opt.ignoreGroups,\r\n        (match, node) => {\r\n          return this.opt.filter(node, match, totalMatches);\r\n        },\r\n        eachCb,\r\n        () => {\r\n          if (totalMatches === 0) {\r\n            this.opt.noMatch(regexp);\r\n          }\r\n          this.opt.done(totalMatches);\r\n        }\r\n      );\r\n    }\r\n    mark(sv, opt) {\r\n      this.opt = opt;\r\n      let totalMatches = 0,\r\n        fn = \"wrapMatches\";\r\n      const { keywords: kwArr, length: kwArrLen } = this.getSeparatedKeywords(\r\n          typeof sv === \"string\" ? [sv] : sv\r\n        ),\r\n        handler = (kw) => {\r\n          const regex = new RegExpCreator(this.opt).create(kw);\r\n          let matches = 0;\r\n          this.log(`Searching with expression \"${regex}\"`);\r\n          this[fn](\r\n            regex,\r\n            1,\r\n            (term, node) => {\r\n              return this.opt.filter(node, kw, totalMatches, matches);\r\n            },\r\n            (element) => {\r\n              matches++;\r\n              totalMatches++;\r\n              this.opt.each(element);\r\n            },\r\n            () => {\r\n              if (matches === 0) {\r\n                this.opt.noMatch(kw);\r\n              }\r\n              if (kwArr[kwArrLen - 1] === kw) {\r\n                this.opt.done(totalMatches);\r\n              } else {\r\n                handler(kwArr[kwArr.indexOf(kw) + 1]);\r\n              }\r\n            }\r\n          );\r\n        };\r\n      if (this.opt.acrossElements) {\r\n        fn = \"wrapMatchesAcrossElements\";\r\n      }\r\n      if (kwArrLen === 0) {\r\n        this.opt.done(totalMatches);\r\n      } else {\r\n        handler(kwArr[0]);\r\n      }\r\n    }\r\n    markRanges(rawRanges, opt) {\r\n      this.opt = opt;\r\n      let totalMatches = 0,\r\n        ranges = this.checkRanges(rawRanges);\r\n      if (ranges && ranges.length) {\r\n        this.log(\r\n          \"Starting to mark with the following ranges: \" +\r\n            JSON.stringify(ranges)\r\n        );\r\n        this.wrapRangeFromIndex(\r\n          ranges,\r\n          (node, range, match, counter) => {\r\n            return this.opt.filter(node, range, match, counter);\r\n          },\r\n          (element, range) => {\r\n            totalMatches++;\r\n            this.opt.each(element, range);\r\n          },\r\n          () => {\r\n            this.opt.done(totalMatches);\r\n          }\r\n        );\r\n      } else {\r\n        this.opt.done(totalMatches);\r\n      }\r\n    }\r\n    unmark(opt) {\r\n      this.opt = opt;\r\n      let sel = this.opt.element ? this.opt.element : \"*\";\r\n      sel += \"[data-markjs]\";\r\n      if (this.opt.className) {\r\n        sel += `.${this.opt.className}`;\r\n      }\r\n      this.log(`Removal selector \"${sel}\"`);\r\n      this.iterator.forEachNode(\r\n        NodeFilter.SHOW_ELEMENT,\r\n        (node) => {\r\n          this.unwrapMatches(node);\r\n        },\r\n        (node) => {\r\n          const matchesSel = DOMIterator.matches(node, sel),\r\n            matchesExclude = this.matchesExclude(node);\r\n          if (!matchesSel || matchesExclude) {\r\n            return NodeFilter.FILTER_REJECT;\r\n          } else {\r\n            return NodeFilter.FILTER_ACCEPT;\r\n          }\r\n        },\r\n        this.opt.done\r\n      );\r\n    }\r\n  }\r\n\r\n  function Mark$1(ctx) {\r\n    const instance = new Mark(ctx);\r\n    this.mark = (sv, opt) => {\r\n      instance.mark(sv, opt);\r\n      return this;\r\n    };\r\n    this.markRegExp = (sv, opt) => {\r\n      instance.markRegExp(sv, opt);\r\n      return this;\r\n    };\r\n    this.markRanges = (sv, opt) => {\r\n      instance.markRanges(sv, opt);\r\n      return this;\r\n    };\r\n    this.unmark = (opt) => {\r\n      instance.unmark(opt);\r\n      return this;\r\n    };\r\n    return this;\r\n  }\r\n\r\n  return Mark$1;\r\n});\r\n";